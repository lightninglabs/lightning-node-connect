package mailbox

import (
	"crypto/rand"
	"encoding/hex"
	"testing"

	"github.com/btcsuite/btcd/btcec"
	"github.com/stretchr/testify/require"
)

var (
	serverGeneratorPoint, _ = hex.DecodeString(
		"02f5333fc36e2f6c8560606febdaa1dde5116ac5f60927f32dae5bfa2941" +
			"6e9036",
	)
	clientGeneratorPoint, _ = hex.DecodeString(
		"0242da01de8fb6b8a2e27c532e98a6d6b88303b4732f1195e7f43abb0709" +
			"813f77",
	)
)

// TestHash2Curve tests that the server and client generator points M and N
// can be generated by hashing static strings to our curve, thereby generating
// points that nobody knows the discrete log of.
func TestHash2Curve(t *testing.T) {
	serverG, err := Hash2Curve([]byte(ServerPointPreimage))
	require.NoError(t, err)
	require.Equal(t, serverGeneratorPoint, serverG.SerializeCompressed())

	clientG, err := Hash2Curve([]byte(ClientPointPreimage))
	require.NoError(t, err)
	require.Equal(t, clientGeneratorPoint, clientG.SerializeCompressed())
}

// TestSPAKE2MaskUnmask tests that an ephemeral public key can be masked by
// adding the product of client/server specific generator point and the
// stretched one-time-password and then unmasked again using the reverse
// operation.
func TestSPAKE2MaskUnmask(t *testing.T) {
	var password [NumPasswordBytes]byte
	for i := 0; i < 100; i++ {
		privKey, err := btcec.NewPrivateKey(btcec.S256())
		require.NoError(t, err)

		_, err = rand.Read(password[:])
		require.NoError(t, err)

		masked, err := SPAKE2Mask(
			privKey.PubKey(), ServerPointPreimage, password[:],
		)
		require.NoError(t, err)
		require.NotEqual(t, privKey.PubKey(), masked)

		unmasked, err := SPAKE2Unmask(
			masked, ServerPointPreimage, password[:],
		)
		require.NoError(t, err)
		require.Equal(t, privKey.PubKey(), unmasked)
	}
}
